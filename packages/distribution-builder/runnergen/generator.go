package runnergen

import (
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"text/template"
)

const runnerTemplate = `
// Auto-generated by knative-next-builder
console.log('DEBUG: Runner init');

process.on('uncaughtException', (err) => {
  console.error('DEBUG: Uncaught Exception:', err);
  process.exit(1);
});
process.on('unhandledRejection', (reason, promise) => {
  console.error('DEBUG: Unhandled Rejection:', reason);
  process.exit(1);
});

import { createRequire } from 'module';
const require = createRequire(import.meta.url);
const path = require('path');
console.log('DEBUG: Imports loaded. import.meta.url:', import.meta.url);


// Inject Next.js Config
const nextConfig = {{ .ConfigJSON }};

process.env.NODE_ENV = 'production';
process.env.__NEXT_PRIVATE_STANDALONE_CONFIG = JSON.stringify(nextConfig);

// Standalone output mirrors the absolute source path.
// We need to point 'dir' to the location of the app inside the standalone file structure.
// The Go builder injects the relative path from the root (e.g. "Users/banna/...")
const relativeAppDir = "{{ .RelativeAppDir }}";
const dir = path.join(process.cwd(), relativeAppDir);

const hostname = process.env.HOSTNAME || '0.0.0.0';
const port = parseInt(process.env.PORT || '3000', 10);
const keepAliveTimeout = parseInt(process.env.KEEP_ALIVE_TIMEOUT || '0', 10) || undefined;

// Inject Environment Variables from Config
if (nextConfig.env) {
  Object.entries(nextConfig.env).forEach(([key, value]) => {
    if (value !== undefined && value !== null) {
      process.env[key] = String(value);
    }
  });
  console.log('DEBUG: Injected environment variables from config:', Object.keys(nextConfig.env));
}

console.log('Starting Next.js server with Bun...');
console.log('Hostname:', hostname);
console.log('Port:', port);
console.log('Directory:', dir);

// Debug: Check if .next exists and is readable
try {
  const fs = require('fs');
  if (fs.existsSync(dir)) {
     console.log('Contents of dir:', fs.readdirSync(dir));
     const nextDir = path.join(dir, '.next');
     if (fs.existsSync(nextDir)) {
       console.log('Contents of .next:', fs.readdirSync(nextDir));
     } else {
       console.error('.next directory missing at:', nextDir);
     }
  } else {
     console.error('App directory missing:', dir);
  }
} catch (e) {
  console.error('Debug Check Failed:', e);
}

// Use require to bypass potential ESM export restrictions in Next.js packages
const { startServer } = require('next/dist/server/lib/start-server');

startServer({
  dir,
  isDev: false,
  config: nextConfig,
  hostname,
  port,
  // allowRetry: false, // Not needed for prod
  keepAliveTimeout,
}).catch((err) => {
  console.error('Failed to start server:', err);
  process.exit(1);
});
`

type GeneratorData struct {
	ConfigJSON     string
	RelativeAppDir string
}

// GenerateRunner creates the bun-runner.ts file in the specified directory
func GenerateRunner(config map[string]interface{}, outputDir, relativeAppDir string) (string, error) {
	// serialized config
	configBytes, err := json.Marshal(config)
	if err != nil {
		return "", fmt.Errorf("failed to marshal next config: %w", err)
	}

	data := GeneratorData{
		ConfigJSON:     string(configBytes),
		RelativeAppDir: relativeAppDir,
	}

	tmpl, err := template.New("runner").Parse(runnerTemplate)
	if err != nil {
		return "", fmt.Errorf("failed to parse runner template: %w", err)
	}

	// Ensure output directory exists
	if err := os.MkdirAll(outputDir, 0755); err != nil {
		return "", fmt.Errorf("failed to create output dir: %w", err)
	}

	outPath := filepath.Join(outputDir, "bun-runner.ts")
	f, err := os.Create(outPath)
	if err != nil {
		return "", fmt.Errorf("failed to create runner file: %w", err)
	}
	defer f.Close()

	if err := tmpl.Execute(f, data); err != nil {
		return "", fmt.Errorf("failed to execute template: %w", err)
	}

	return outPath, nil
}

// GeneratePackageJSON creates a minimal package.json for runtime dependencies
func GeneratePackageJSON(outputDir string) error {
	pkg := map[string]interface{}{
		"name": "knative-built-app",
		"private": true,
		"dependencies": map[string]string{
			"next": "16.0.3",
			"react": "^19.0.0",
			"react-dom": "^19.0.0",
			"sharp": "^0.33.2",
			"@swc/helpers": "^0.5.0",
			"styled-jsx": "^5.1.1",
		},
	}
	
	bytes, err := json.MarshalIndent(pkg, "", "  ")
	if err != nil {
		return err
	}
	
	return os.WriteFile(filepath.Join(outputDir, "package.json"), bytes, 0644)
}
