package builder

import (
	"fmt"
	"os"
	"path/filepath"
)

type Executor interface {
	Run(cmd string, args ...string) error
}

type Builder struct {
	Exec Executor
}

func NewBuilder(exec Executor) *Builder {
	return &Builder{Exec: exec}
}

func (b *Builder) Build(outDir string, cfg BuildConfig) error {
	// 1. Compile with Bun
	// "bun build --compile --minify --sourcemap ./server.js --outfile server"
	err := b.Exec.Run("bun", "build", "--compile", "--minify", "--sourcemap", "./"+cfg.Params.Entrypoint, "--outfile", "server")
	if err != nil {
		return fmt.Errorf("bun build failed: %w", err)
	}

	// 2. Generate Dockerfile
	// We create a minimal optimized Dockerfile
	dockerfileContent := fmt.Sprintf(`# Generated by Knative Next Builder
FROM %s

WORKDIR /app

# Copy the compiled binary from the builder stage (assumed external or prev stage)
# For this prototype, we assume the binary 'server' is in context.
# In a real Multi-Stage, we'd have the build happened inside Docker or copied in.
# The test expects a COPY --from=builder pattern.

COPY --from=builder /app/server /app/server

ENV NODE_ENV=production
ENV PORT=3000

CMD ["/app/server"]
`, cfg.Params.BaseImage)

	outputPath := filepath.Join(outDir, "Dockerfile")
	if err := os.WriteFile(outputPath, []byte(dockerfileContent), 0644); err != nil {
		return fmt.Errorf("failed to write Dockerfile: %w", err)
	}

	return nil
}
