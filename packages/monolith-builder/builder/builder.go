package builder

import (
	"fmt"
	"os"
	"path/filepath"
)

type Executor interface {
	Run(cmd string, args ...string) error
}

type Builder struct {
	Exec Executor
}

func NewBuilder(exec Executor) *Builder {
	return &Builder{Exec: exec}
}

func (b *Builder) Build(outDir string, cfg BuildConfig) error {
	// 1. Compile with Bun
	// Output the binary directly into the isolated directory
	outputBin := filepath.Join(outDir, "server")
	// "bun build --compile --bytecode --minify --sourcemap --define:process.env.NODE_ENV="production" ./server.js --outfile dist-isolated/server"
	err := b.Exec.Run("bun", "build", "--compile", "--bytecode", "--minify", "--sourcemap", "--define:process.env.NODE_ENV=\"production\"", "./"+cfg.Params.Entrypoint, "--outfile", outputBin)
	if err != nil {
		return fmt.Errorf("bun build failed: %w", err)
	}

	// 2. Generate Dockerfile
	// We create a minimal optimized Dockerfile
	// NOTE: We assume 'server' binary is sitting next to Dockerfile in outDir
	dockerfileContent := fmt.Sprintf(`# Generated by Knative Next Builder
FROM %s

WORKDIR /app

# Copy the compiled binary from the build context
COPY server /app/server

ENV NODE_ENV=production
ENV PORT=3000

CMD ["/app/server"]
`, cfg.Params.BaseImage)

	outputPath := filepath.Join(outDir, "Dockerfile")
	if err := os.WriteFile(outputPath, []byte(dockerfileContent), 0644); err != nil {
		return fmt.Errorf("failed to write Dockerfile: %w", err)
	}

	return nil
}
