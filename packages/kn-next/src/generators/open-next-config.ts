import { writeFileSync } from "node:fs";
import path from "node:path";
import type { KnativeNextConfig } from "../config";

/**
 * Maps kn-next storage/cache providers to OpenNext adapter paths.
 * These paths use the @kn-next/config package exports.
 */
const ADAPTER_MAP = {
    storage: {
        // Incremental cache (ISR + fetch data)
        redis: "@kn-next/config/adapters/redis-cache",
        gcs: "@kn-next/config/adapters/gcs-cache",
        s3: "@opennextjs/aws/overrides/incrementalCache/s3",
        minio: "@kn-next/config/adapters/gcs-cache", // MinIO uses S3-compatible API
        azure: "@kn-next/config/adapters/azure-cache", // Future
    },
    cache: {
        // Tag cache (invalidation tracking)
        redis: "@kn-next/config/adapters/redis-tag-cache",
        dynamodb: "@opennextjs/aws/overrides/tagCache/dynamodb",
    },
    queue: {
        kafka: "@kn-next/config/adapters/kafka-queue",
        sqs: "@opennextjs/aws/overrides/queue/sqs",
        direct: "@opennextjs/aws/overrides/queue/direct",
    },
} as const;

export interface GenerateOpenNextConfigOptions {
    config: KnativeNextConfig;
    outputDir: string;
    enableKafkaQueue?: boolean; // Deprecated - use config.queue instead
}

/**
 * Determines the queue adapter based on config.
 * For Knative, Kafka is the recommended default for ISR revalidation.
 */
function getQueueAdapter(
    config: KnativeNextConfig,
    enableKafkaQueue?: boolean,
): string {
    // First check if config.queue is explicitly set
    if (config.queue) {
        return config.queue.provider === "kafka"
            ? ADAPTER_MAP.queue.kafka
            : ADAPTER_MAP.queue.direct;
    }
    // Fall back to enableKafkaQueue flag or default to Kafka for Knative
    return enableKafkaQueue !== false
        ? ADAPTER_MAP.queue.kafka
        : ADAPTER_MAP.queue.direct;
}

/**
 * Generates open-next.config.ts based on user's kn-next.config.ts.
 * This implements the Internalization Principle - users never see this file.
 */
export function generateOpenNextConfig(
    options: GenerateOpenNextConfigOptions,
): string {
    const { config, outputDir, enableKafkaQueue } = options;

    // Use Redis for incremental cache if cache provider is redis, otherwise use storage provider
    const useRedisForCache = config.cache?.provider === "redis";
    const storageAdapter = useRedisForCache
        ? ADAPTER_MAP.storage.redis
        : (ADAPTER_MAP.storage[
              config.storage.provider as keyof typeof ADAPTER_MAP.storage
          ] ?? ADAPTER_MAP.storage.gcs);
    const cacheAdapter = ADAPTER_MAP.cache[config.cache?.provider ?? "redis"];
    const queueAdapter = getQueueAdapter(config, enableKafkaQueue);
    const queueProvider =
        queueAdapter === ADAPTER_MAP.queue.kafka ? "kafka" : "direct";

    const configContent = `// AUTO-GENERATED by kn-next build - DO NOT EDIT
// Source: kn-next.config.ts
import type { OpenNextConfig } from '@opennextjs/aws/types/open-next';

const config: OpenNextConfig = {
    default: {
        override: {
            // Storage provider: ${config.storage.provider}
            incrementalCache: async () => {
                const mod = await import('${storageAdapter}');
                return mod.default;
            },
            
            // Cache provider: ${config.cache?.provider ?? "redis"}
            tagCache: async () => {
                const mod = await import('${cacheAdapter}');
                return mod.default;
            },
            
            // Queue provider: ${queueProvider}
            queue: async () => {
                const mod = await import('${queueAdapter}');
                return mod.default;
            },
            
            // Use Node.js converter for HTTP requests (not Lambda/API Gateway)
            converter: 'node',
            
            // Use Node.js wrapper for Knative (not Lambda)
            wrapper: async () => {
                const mod = await import('@kn-next/config/adapters/node-server');
                return mod.default;
            },
        },
    },
};

export default config;
`;

    const outputPath = path.join(outputDir, "open-next.config.ts");
    writeFileSync(outputPath, configContent, "utf-8");

    console.info(`[kn-next] Generated ${outputPath}`);
    return outputPath;
}

/**
 * Provider-specific environment variable generators.
 * Following Open/Closed Principle: add new providers without modifying existing code.
 */
type EnvVarGenerator<T> = (
    config: T,
    appName: string,
) => Record<string, string>;

// biome-ignore lint/suspicious/noExplicitAny: intentional
const storageEnvVarGenerators: Record<string, EnvVarGenerator<any>> = {
    gcs: (storage, appName) => ({
        GCS_BUCKET_NAME: storage.bucket,
        GCS_BUCKET_KEY_PREFIX: appName,
    }),
    s3: (storage) => ({
        CACHE_BUCKET_NAME: storage.bucket,
        CACHE_BUCKET_REGION: storage.region ?? "us-east-1",
        ...(storage.endpoint ? { S3_ENDPOINT: storage.endpoint } : {}),
    }),
    minio: (storage) => ({
        CACHE_BUCKET_NAME: storage.bucket,
        CACHE_BUCKET_REGION: storage.region ?? "us-east-1",
        ...(storage.endpoint ? { S3_ENDPOINT: storage.endpoint } : {}),
    }),
};

// biome-ignore lint/suspicious/noExplicitAny: intentional
const cacheEnvVarGenerators: Record<string, EnvVarGenerator<any>> = {
    redis: (cache, appName) => ({
        REDIS_URL: cache.url,
        REDIS_KEY_PREFIX: cache.keyPrefix ?? appName,
    }),
    dynamodb: (cache) => ({
        CACHE_DYNAMO_TABLE: cache.tableName,
        CACHE_BUCKET_REGION: cache.region,
    }),
};

/**
 * Generates environment variables configuration for the adapters.
 * Uses provider-specific generators for extensibility.
 */
export function getRequiredEnvVars(
    config: KnativeNextConfig,
): Record<string, string> {
    const storageGenerator = storageEnvVarGenerators[config.storage.provider];
    const cacheGenerator = config.cache
        ? cacheEnvVarGenerators[config.cache.provider]
        : null;

    return {
        ...(storageGenerator?.(config.storage, config.name) ?? {}),
        ...(cacheGenerator?.(config.cache, config.name) ?? {}),
    };
}
