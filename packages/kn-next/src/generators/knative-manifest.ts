import { writeFileSync } from 'node:fs';
import path from 'node:path';
import type { KnativeNextConfig } from '../config';
import { getRequiredEnvVars } from './open-next-config';

export interface GenerateKnativeManifestOptions {
  config: KnativeNextConfig;
  outputDir: string;
  imageTag?: string;
  namespace?: string;
  enableKafkaQueue?: boolean;
  additionalEnvVars?: Record<string, string>; // Infrastructure connection vars
}

/**
 * Generates Knative Service manifest from kn-next.config.ts.
 * Includes all required environment variables for the adapters.
 * Optionally includes bytecode cache PVC and volume mounts.
 */
export function generateKnativeManifest(options: GenerateKnativeManifestOptions): string {
  const {
    config,
    outputDir,
    imageTag = 'latest',
    namespace = 'default',
    enableKafkaQueue = false,
    additionalEnvVars = {},
  } = options;

  const envVars = { ...getRequiredEnvVars(config), ...additionalEnvVars };

  // Add Kafka env vars if enabled
  if (enableKafkaQueue) {
    envVars.KAFKA_BROKER_URL = '${KAFKA_BROKER_URL}';
    envVars.KAFKA_REVALIDATION_TOPIC = `${config.name}-revalidation`;
  }

  // Add NODE_COMPILE_CACHE env var if bytecode caching is enabled
  const bytecodeCacheEnabled = config.bytecodeCache?.enabled === true;
  if (bytecodeCacheEnabled) {
    envVars.NODE_COMPILE_CACHE = `/cache/bytecode/${imageTag}`;
  }

  // Add observability env vars
  const observabilityEnabled = config.observability?.enabled === true;
  if (observabilityEnabled) {
    envVars.KN_APP_NAME = config.name;
  }

  // Build Prometheus annotations if observability is enabled
  const prometheusAnnotations = observabilityEnabled
    ? `\n        prometheus.io/scrape: "true"\n        prometheus.io/port: "3000"\n        prometheus.io/path: "/metrics"`
    : '';

  // Format env vars for YAML (12-space indent for env array items)
  const envVarsYaml = Object.entries(envVars)
    .map(([key, value]) => `            - name: ${key}\n              value: "${value}"`)
    .join('\n');

  // Build volume mount and volume sections if bytecode cache is enabled
  const volumeMountYaml = bytecodeCacheEnabled
    ? `
          volumeMounts:
            - name: bytecode-cache
              mountPath: /cache/bytecode`
    : '';

  const volumeYaml = bytecodeCacheEnabled
    ? `
      volumes:
        - name: bytecode-cache
          persistentVolumeClaim:
            claimName: ${config.name}-bytecode-cache`
    : '';

  const manifest = `# AUTO-GENERATED by kn-next build - DO NOT EDIT
# Source: kn-next.config.ts
apiVersion: serving.knative.dev/v1
kind: Service
metadata:
  name: ${config.name}
  namespace: ${namespace}
  labels:
    app: ${config.name}
    generated-by: kn-next
spec:
  template:
    metadata:
      annotations:
        autoscaling.knative.dev/min-scale: "${config.scaling?.minScale ?? 0}"
        autoscaling.knative.dev/max-scale: "${config.scaling?.maxScale ?? 10}"${prometheusAnnotations}
    spec:
      containerConcurrency: 100
      timeoutSeconds: 300
      containers:
        - image: ${config.registry}/${config.name}:${imageTag}
          ports:
            - containerPort: 3000
          env:
            - name: NODE_ENV
              value: "production"
${envVarsYaml}
          resources:
            requests:
              cpu: "100m"
              memory: "256Mi"
            limits:
              cpu: "1000m"
              memory: "512Mi"${volumeMountYaml}
          readinessProbe:
            httpGet:
              path: /api/health
              port: 3000
            initialDelaySeconds: 5
            periodSeconds: 10
          livenessProbe:
            httpGet:
              path: /api/health
              port: 3000
            initialDelaySeconds: 10
            periodSeconds: 30${volumeYaml}
`;

  // Generate PVC manifest if bytecode cache is enabled
  const bytecodePvcManifest = bytecodeCacheEnabled
    ? `---
# Bytecode cache PVC - shared across pods for V8 compile cache
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: ${config.name}-bytecode-cache
  namespace: ${namespace}
  labels:
    app: ${config.name}
    generated-by: kn-next
spec:
  accessModes:
    - ReadWriteMany
  resources:
    requests:
      storage: ${config.bytecodeCache?.storageSize ?? '512Mi'}
`
    : '';

  const fullManifest = manifest + bytecodePvcManifest;

  const outputPath = path.join(outputDir, 'knative-service.yaml');
  writeFileSync(outputPath, fullManifest, 'utf-8');

  console.log(`[kn-next] Generated ${outputPath}`);
  if (bytecodeCacheEnabled) {
    console.log(`[kn-next] Bytecode caching enabled (NODE_COMPILE_CACHE=/cache/bytecode/${imageTag})`);
  }
  return outputPath;
}

/**
 * Generates Knative Eventing resources for ISR revalidation via Kafka.
 */
export function generateKafkaEventingManifest(options: {
  config: KnativeNextConfig;
  outputDir: string;
  kafkaBroker: string;
}): string {
  const { config, outputDir, kafkaBroker } = options;
  const topic = `${config.name}-revalidation`;

  const manifest = `# AUTO-GENERATED by kn-next build - DO NOT EDIT
# Knative Eventing configuration for ISR revalidation
apiVersion: sources.knative.dev/v1beta1
kind: KafkaSource
metadata:
  name: ${config.name}-revalidation-source
spec:
  consumerGroup: ${config.name}-revalidation
  bootstrapServers:
    - ${kafkaBroker}
  topics:
    - ${topic}
  sink:
    ref:
      apiVersion: serving.knative.dev/v1
      kind: Service
      name: ${config.name}-revalidator
---
apiVersion: serving.knative.dev/v1
kind: Service
metadata:
  name: ${config.name}-revalidator
spec:
  template:
    spec:
      containers:
        - image: ${config.registry}/${config.name}-revalidator:latest
          env:
            - name: TARGET_HOST
              value: "${config.name}.default.svc.cluster.local"
`;

  const outputPath = path.join(outputDir, 'knative-eventing.yaml');
  writeFileSync(outputPath, manifest, 'utf-8');

  console.log(`[kn-next] Generated ${outputPath}`);
  return outputPath;
}
