import { writeFileSync } from "node:fs";
import path from "node:path";
import type { KnativeNextConfig } from "../config";
import { getRequiredEnvVars } from "./open-next-config";

export interface GenerateKnativeManifestOptions {
    config: KnativeNextConfig;
    outputDir: string;
    imageTag?: string;
    namespace?: string;
    enableKafkaQueue?: boolean;
    additionalEnvVars?: Record<string, string>; // Infrastructure connection vars
}

/**
 * Generates Knative Service manifest from kn-next.config.ts.
 * Includes all required environment variables for the adapters.
 * Optionally includes bytecode cache PVC and volume mounts.
 */
export function generateKnativeManifest(
    options: GenerateKnativeManifestOptions,
): string {
    const {
        config,
        outputDir,
        imageTag = "latest",
        namespace = "default",
        enableKafkaQueue = false,
        additionalEnvVars = {},
    } = options;

    const envVars = { ...getRequiredEnvVars(config), ...additionalEnvVars };

    // Add Kafka env vars if enabled
    if (enableKafkaQueue) {
        // biome-ignore lint/suspicious/noTemplateCurlyInString: required for K8s manifest
        envVars.KAFKA_BROKER_URL = "${KAFKA_BROKER_URL}";
        envVars.KAFKA_REVALIDATION_TOPIC = `${config.name}-revalidation`;
    }

    // Add NODE_COMPILE_CACHE env var if bytecode caching is enabled
    const bytecodeCacheEnabled = config.bytecodeCache?.enabled === true;
    if (bytecodeCacheEnabled) {
        envVars.NODE_COMPILE_CACHE = `/cache/bytecode/${imageTag}`;
    }

    // Add observability env vars
    const observabilityEnabled = config.observability?.enabled === true;
    if (observabilityEnabled) {
        envVars.KN_APP_NAME = config.name;
    }

    // Build Prometheus annotations if observability is enabled
    const prometheusAnnotations = observabilityEnabled
        ? `\n        prometheus.io/scrape: "true"\n        prometheus.io/port: "3000"\n        prometheus.io/path: "/api/metrics"`
        : "";

    // Format env vars for YAML (12-space indent for env array items)
    const envVarsYaml = Object.entries(envVars)
        .map(
            ([key, value]) =>
                `            - name: ${key}\n              value: "${value}"`,
        )
        .join("\n");

    // Handle mapped secrets (envMap)
    const envMapEntries = config.secrets?.envMap
        ? Object.entries(config.secrets.envMap).map(
              ([envName, ref]) =>
                  `            - name: ${envName}\n              valueFrom:\n                secretKeyRef:\n                  name: ${ref.name}\n                  key: ${ref.key ?? envName}`,
          )
        : [];

    const allEnvItems = [envVarsYaml, ...envMapEntries]
        .filter(Boolean)
        .join("\n");

    // Handle entire secrets injected as envFrom
    const envFromYaml = config.secrets?.envFrom?.length
        ? `\n          envFrom:\n${config.secrets.envFrom.map((secretName) => `            - secretRef:\n                name: ${secretName}`).join("\n")}`
        : "";
    const volumeMountYaml = bytecodeCacheEnabled
        ? `
          volumeMounts:
            - name: bytecode-cache
              mountPath: /cache/bytecode`
        : "";

    const volumeYaml = bytecodeCacheEnabled
        ? `
      volumes:
        - name: bytecode-cache
          persistentVolumeClaim:
            claimName: ${config.name}-bytecode-cache`
        : "";

    const manifest = `# AUTO-GENERATED by kn-next build - DO NOT EDIT
# Source: kn-next.config.ts
apiVersion: serving.knative.dev/v1
kind: Service
metadata:
  name: ${config.name}
  namespace: ${namespace}
  labels:
    app: ${config.name}
    generated-by: kn-next
spec:
  # Knative uses the latest ready revision by default
  template:
    metadata:
      annotations:
        autoscaling.knative.dev/min-scale: "${config.scaling?.minScale ?? 0}"
        autoscaling.knative.dev/max-scale: "${config.scaling?.maxScale ?? 10}"${prometheusAnnotations}
    spec:
      serviceAccountName: ${config.name}-sa
      containerConcurrency: 100
      timeoutSeconds: 300
      containers:
        - image: ${config.registry}/${config.name}:${imageTag}
          ports:
            - containerPort: 3000
          env:
            - name: HOSTNAME
              value: "0.0.0.0"
            - name: NODE_ENV
              value: "production"
${allEnvItems}${envFromYaml}
          resources:
            requests:
              cpu: "${config.scaling?.cpuRequest ?? "250m"}"
              memory: "${config.scaling?.memoryRequest ?? "512Mi"}"
            limits:
              cpu: "${config.scaling?.cpuLimit ?? "1000m"}"
              memory: "${config.scaling?.memoryLimit ?? "1Gi"}"${volumeMountYaml}
          readinessProbe:
            httpGet:
              path: ${config.healthCheckPath ?? "/api/health"}
              port: 3000
            initialDelaySeconds: 5
            periodSeconds: 10
          livenessProbe:
            httpGet:
              path: ${config.healthCheckPath ?? "/api/health"}
              port: 3000
            initialDelaySeconds: 15
            periodSeconds: 30${volumeYaml}
`;

    // Generate PVC manifest if bytecode cache is enabled
    const bytecodePvcManifest = bytecodeCacheEnabled
        ? `---
# Bytecode cache PVC - shared across pods for V8 compile cache
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: ${config.name}-bytecode-cache
  namespace: ${namespace}
  labels:
    app: ${config.name}
    generated-by: kn-next
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: ${config.bytecodeCache?.storageSize ?? "512Mi"}
`
        : "";

    // Generate ServiceAccount manifest for least-privilege RBAC
    const serviceAccountManifest = `---
# Least-privilege ServiceAccount to restrict K8s API access
apiVersion: v1
kind: ServiceAccount
metadata:
  name: ${config.name}-sa
  namespace: ${namespace}
automountServiceAccountToken: false
`;

    const fullManifest =
        manifest + bytecodePvcManifest + serviceAccountManifest;

    const outputPath = path.join(outputDir, "knative-service.yaml");
    writeFileSync(outputPath, fullManifest, "utf-8");

    console.info(`[kn-next] Generated ${outputPath}`);
    if (bytecodeCacheEnabled) {
        console.info(
            `[kn-next] Bytecode caching enabled (NODE_COMPILE_CACHE=/cache/bytecode/${imageTag})`,
        );
    }
    return outputPath;
}

/**
 * Generates Knative Eventing resources for ISR revalidation via Kafka.
 */
export function generateKafkaEventingManifest(options: {
    config: KnativeNextConfig;
    outputDir: string;
    kafkaBroker: string;
}): string {
    const { config, outputDir, kafkaBroker } = options;
    const topic = `${config.name}-revalidation`;

    const manifest = `# AUTO-GENERATED by kn-next build - DO NOT EDIT
# Knative Eventing configuration for ISR revalidation
apiVersion: sources.knative.dev/v1beta1
kind: KafkaSource
metadata:
  name: ${config.name}-revalidation-source
spec:
  consumerGroup: ${config.name}-revalidation
  bootstrapServers:
    - ${kafkaBroker}
  topics:
    - ${topic}
  sink:
    ref:
      apiVersion: serving.knative.dev/v1
      kind: Service
      name: ${config.name}-revalidator
---
apiVersion: serving.knative.dev/v1
kind: Service
metadata:
  name: ${config.name}-revalidator
spec:
  template:
    spec:
      containers:
        - image: ${config.registry}/${config.name}-revalidator:latest
          env:
            - name: TARGET_HOST
              value: "${config.name}.default.svc.cluster.local"
`;

    const outputPath = path.join(outputDir, "knative-eventing.yaml");
    writeFileSync(outputPath, manifest, "utf-8");

    console.info(`[kn-next] Generated ${outputPath}`);
    return outputPath;
}

/**
 * Generates an entrypoint script that fixes PVC ownership for the bytecode cache.
 *
 * When Knative mounts a PVC, the filesystem is owned by root.
 * Since the container runs as the 'node' user (uid 1000), V8's compile cache
 * cannot write bytecode files without this fix.
 *
 * Knative does not support initContainers (feature flag off by default),
 * so we use an entrypoint script that:
 * 1. Runs as root on container start
 * 2. chowns the cache directory to the node user
 * 3. Creates the build-specific subdirectory
 * 4. Drops privileges via su-exec and executes the Node.js server
 *
 * The Dockerfile must:
 * - Install su-exec: `RUN apk add --no-cache su-exec`
 * - NOT set `USER node` (the entrypoint handles privilege dropping)
 * - Use: `ENTRYPOINT ["/entrypoint.sh"]`
 */
export function generateEntrypoint(options: {
    config: KnativeNextConfig;
    outputDir: string;
}): string {
    const { outputDir } = options;

    const script = `#!/bin/sh
# AUTO-GENERATED by kn-next build - DO NOT EDIT
# Fixes PVC ownership for V8 bytecode cache, then drops to node user.
#
# Why: Knative-mounted PVCs are root-owned. The 'node' user (uid 1000)
# cannot write V8 compile cache files without this permission fix.
# Knative does not support initContainers, so we fix it at startup.

CACHE_BASE="/cache/bytecode"

if [ -d "$CACHE_BASE" ]; then
  echo "[kn-next] Fixing bytecode cache permissions..."
  chown -R node:node "$CACHE_BASE" 2>/dev/null || true

  # Create the build-specific subdirectory if NODE_COMPILE_CACHE is set
  if [ -n "$NODE_COMPILE_CACHE" ]; then
    mkdir -p "$NODE_COMPILE_CACHE" 2>/dev/null || true
    chown -R node:node "$NODE_COMPILE_CACHE" 2>/dev/null || true
  fi

  echo "[kn-next] Cache dir ready: $(ls -la $CACHE_BASE | head -5)"
fi

# Override HOSTNAME — Kubernetes sets it to the pod name (e.g. my-app-00001-...-bqrct),
# which causes Next.js to bind on that hostname instead of all interfaces.
# Without this, queue-proxy health checks on 127.0.0.1:3000 fail with "connection refused".
export HOSTNAME=0.0.0.0

# Fix Next.js cache directory permissions — the .next dir is root-owned from the
# Docker build, but Next.js 16 needs write access for prerender cache (.next/cache)
# and segment files (.next/server/app/*.segments). Without this fix, cache writes
# fail with EACCES and OpenNext cache adapters never fire.
NEXT_DIR="$(pwd)/.next"
if [ -d "$NEXT_DIR" ]; then
  mkdir -p "$NEXT_DIR/cache" 2>/dev/null || true
  chown -R node:node "$NEXT_DIR/cache" 2>/dev/null || true
  chown -R node:node "$NEXT_DIR/server" 2>/dev/null || true
  echo "[kn-next] Fixed .next cache permissions"
fi

# Drop privileges and start the Next.js standalone server
# (OpenNext produces index.mjs as the default server function entrypoint)
exec su-exec node node index.mjs
`;

    const outputPath = path.join(outputDir, "entrypoint.sh");
    writeFileSync(outputPath, script, { encoding: "utf-8", mode: 0o755 });

    console.info(
        "[kn-next] Generated entrypoint.sh (bytecode cache PVC permissions fix)",
    );
    return outputPath;
}
