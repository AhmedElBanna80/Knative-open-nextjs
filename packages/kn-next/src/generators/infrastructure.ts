import { writeFileSync } from "node:fs";
import { join } from "node:path";
import type {
    KnativeNextConfig,
    MinioInfraConfig,
    ObservabilityConfig,
    PostgresConfig,
    RedisInfraConfig,
} from "../config";

/**
 * Generates Kubernetes/Knative manifests for infrastructure services
 */

export interface InfrastructureOutput {
    manifests: string[];
    envVars: Record<string, string>;
}

export function generateInfrastructure(
    config: KnativeNextConfig,
    outputDir: string,
): InfrastructureOutput {
    const manifests: string[] = [];
    const envVars: Record<string, string> = {};
    const namespace = "default";

    const infra = config.infrastructure;

    // PostgreSQL
    if (infra?.postgres?.enabled) {
        const pgManifest = generatePostgresManifest(
            config.name,
            infra.postgres,
        );
        const pgPath = join(outputDir, "postgres.yaml");
        writeFileSync(pgPath, pgManifest);
        manifests.push(pgPath);

        const pgHost = `${config.name}-postgres.${namespace}.svc.cluster.local`;
        envVars.DATABASE_URL = `postgres://postgres:postgres@${pgHost}:5432/app`;
        console.info(`[kn-next] Generated ${pgPath}`);
    }

    // Redis
    if (infra?.redis?.enabled) {
        const redisManifest = generateRedisManifest(config.name, infra.redis);
        const redisPath = join(outputDir, "redis.yaml");
        writeFileSync(redisPath, redisManifest);
        manifests.push(redisPath);

        const redisHost = `${config.name}-redis.${namespace}.svc.cluster.local`;
        envVars.REDIS_URL = `redis://${redisHost}:6379`;
        console.info(`[kn-next] Generated ${redisPath}`);
    }

    // MinIO
    if (infra?.minio?.enabled) {
        const minioManifest = generateMinioManifest(config.name, infra.minio);
        const minioPath = join(outputDir, "minio.yaml");
        writeFileSync(minioPath, minioManifest);
        manifests.push(minioPath);

        const minioHost = `${config.name}-minio.${namespace}.svc.cluster.local`;
        envVars.MINIO_ENDPOINT = `http://${minioHost}:9000`;
        envVars.MINIO_ACCESS_KEY = infra.minio.accessKey ?? "minioadmin";
        envVars.MINIO_SECRET_KEY = infra.minio.secretKey ?? "minioadmin";
        console.info(`[kn-next] Generated ${minioPath}`);
    }

    // Observability (Prometheus + Grafana)
    if (config.observability?.enabled) {
        const obsManifest = generateObservabilityManifest(
            config.name,
            config.observability,
        );
        const obsPath = join(outputDir, "observability.yaml");
        writeFileSync(obsPath, obsManifest);
        manifests.push(obsPath);
        console.info(`[kn-next] Generated ${obsPath}`);
    }

    return { manifests, envVars };
}

function generatePostgresManifest(
    appName: string,
    config: PostgresConfig,
): string {
    const version = config.version ?? "16";
    const storage = config.storage ?? "1Gi";

    return `# PostgreSQL StatefulSet for ${appName}
# Generated by kn-next CLI
apiVersion: v1
kind: Service
metadata:
  name: ${appName}-postgres
  labels:
    app: ${appName}-postgres
spec:
  ports:
    - port: 5432
      targetPort: 5432
  selector:
    app: ${appName}-postgres
  clusterIP: None
---
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: ${appName}-postgres
spec:
  serviceName: ${appName}-postgres
  replicas: 1
  selector:
    matchLabels:
      app: ${appName}-postgres
  template:
    metadata:
      labels:
        app: ${appName}-postgres
    spec:
      containers:
        - name: postgres
          image: postgres:${version}-alpine
          ports:
            - containerPort: 5432
          env:
            - name: POSTGRES_USER
              value: postgres
            - name: POSTGRES_PASSWORD
              value: postgres
            - name: POSTGRES_DB
              value: app
            - name: PGDATA
              value: /var/lib/postgresql/data/pgdata
          volumeMounts:
            - name: postgres-data
              mountPath: /var/lib/postgresql/data
  volumeClaimTemplates:
    - metadata:
        name: postgres-data
      spec:
        accessModes: ["ReadWriteOnce"]
        resources:
          requests:
            storage: ${storage}
`;
}

function generateRedisManifest(
    appName: string,
    config: RedisInfraConfig,
): string {
    const version = config.version ?? "7";

    return `# Redis Deployment for ${appName}
# Generated by kn-next CLI
apiVersion: v1
kind: Service
metadata:
  name: ${appName}-redis
  labels:
    app: ${appName}-redis
spec:
  ports:
    - port: 6379
      targetPort: 6379
  selector:
    app: ${appName}-redis
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: ${appName}-redis
spec:
  replicas: 1
  selector:
    matchLabels:
      app: ${appName}-redis
  template:
    metadata:
      labels:
        app: ${appName}-redis
    spec:
      containers:
        - name: redis
          image: redis:${version}-alpine
          ports:
            - containerPort: 6379
          args:
            - redis-server
            - --appendonly
            - "yes"
`;
}

function generateMinioManifest(
    appName: string,
    config: MinioInfraConfig,
): string {
    const storage = config.storage ?? "10Gi";
    const accessKey = config.accessKey ?? "minioadmin";
    const secretKey = config.secretKey ?? "minioadmin";

    return `# MinIO StatefulSet for ${appName}
# Generated by kn-next CLI
apiVersion: v1
kind: Service
metadata:
  name: ${appName}-minio
  labels:
    app: ${appName}-minio
spec:
  ports:
    - port: 9000
      targetPort: 9000
      name: api
    - port: 9001
      targetPort: 9001
      name: console
  selector:
    app: ${appName}-minio
---
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: ${appName}-minio
spec:
  serviceName: ${appName}-minio
  replicas: 1
  selector:
    matchLabels:
      app: ${appName}-minio
  template:
    metadata:
      labels:
        app: ${appName}-minio
    spec:
      containers:
        - name: minio
          image: minio/minio:latest
          args:
            - server
            - /data
            - --console-address
            - ":9001"
          ports:
            - containerPort: 9000
            - containerPort: 9001
          env:
            - name: MINIO_ROOT_USER
              value: "${accessKey}"
            - name: MINIO_ROOT_PASSWORD
              value: "${secretKey}"
          volumeMounts:
            - name: minio-data
              mountPath: /data
  volumeClaimTemplates:
    - metadata:
        name: minio-data
      spec:
        accessModes: ["ReadWriteOnce"]
        resources:
          requests:
            storage: ${storage}
`;
}

/**
 * Generates observability resources: ServiceMonitor + Grafana dashboard ConfigMap.
 * The ServiceMonitor tells Prometheus to scrape /metrics from the app pods.
 * The ConfigMap with grafana_dashboard label is auto-provisioned by Grafana's sidecar.
 */
export function generateObservabilityManifest(
    appName: string,
    config: ObservabilityConfig,
): string {
    const scrapeInterval = config.prometheus?.scrapeInterval ?? "15s";
    const grafanaEnabled = config.grafana?.enabled !== false;

    let manifest = `# Observability resources for ${appName}
# Generated by kn-next CLI

# ServiceMonitor ‚Äî tells Prometheus to scrape /metrics from app pods
apiVersion: monitoring.coreos.com/v1
kind: ServiceMonitor
metadata:
  name: ${appName}-metrics
  labels:
    app: ${appName}
    generated-by: kn-next
spec:
  selector:
    matchLabels:
      serving.knative.dev/service: ${appName}
  endpoints:
    - port: http
      path: /metrics
      interval: ${scrapeInterval}
`;

    // Grafana dashboard ConfigMap (auto-provisioned via sidecar label discovery)
    if (grafanaEnabled) {
        // Embed the dashboard JSON inline
        const dashboardJson = generateDashboardJson(appName);

        manifest += `---
# Grafana Dashboard ‚Äî auto-provisioned via grafana_dashboard label
apiVersion: v1
kind: ConfigMap
metadata:
  name: ${appName}-grafana-dashboard
  labels:
    app: ${appName}
    generated-by: kn-next
    grafana_dashboard: "1"
data:
  ${appName}-bytecode.json: |
${dashboardJson
    .split("\n")
    .map((line) => `    ${line}`)
    .join("\n")}
`;
    }

    return manifest;
}

/**
 * Generates the Grafana dashboard JSON for bytecode cache metrics.
 * This is embedded in the ConfigMap for auto-provisioning.
 */
function generateDashboardJson(appName: string): string {
    const dashboard = {
        annotations: { list: [] },
        editable: true,
        panels: [
            {
                title: "üöÄ Cold Start Duration",
                type: "timeseries",
                gridPos: { h: 8, w: 12, x: 0, y: 0 },
                targets: [
                    {
                        expr: `histogram_quantile(0.95, rate(kn_next_startup_duration_seconds_bucket{app="${appName}"}[$__rate_interval]))`,
                        legendFormat: "p95 ({{cache_status}})",
                    },
                    {
                        expr: `histogram_quantile(0.50, rate(kn_next_startup_duration_seconds_bucket{app="${appName}"}[$__rate_interval]))`,
                        legendFormat: "p50 ({{cache_status}})",
                    },
                ],
                fieldConfig: { defaults: { unit: "s" } },
            },
            {
                title: "üî• Warm vs ‚ùÑÔ∏è Cold Starts",
                type: "piechart",
                gridPos: { h: 8, w: 6, x: 12, y: 0 },
                targets: [
                    {
                        expr: `count(kn_next_bytecode_cache_warm_start{app="${appName}"} == 1)`,
                        legendFormat: "warm",
                    },
                    {
                        expr: `count(kn_next_bytecode_cache_warm_start{app="${appName}"} == 0)`,
                        legendFormat: "cold",
                    },
                ],
            },
            {
                title: "üìÅ Cached Files",
                type: "stat",
                gridPos: { h: 4, w: 6, x: 0, y: 8 },
                targets: [
                    {
                        expr: `kn_next_bytecode_cache_files_total{app="${appName}"}`,
                        legendFormat: "{{build_id}}",
                    },
                ],
            },
            {
                title: "üíæ Cache Size",
                type: "stat",
                gridPos: { h: 4, w: 6, x: 6, y: 8 },
                targets: [
                    {
                        expr: `kn_next_bytecode_cache_size_bytes{app="${appName}"}`,
                        legendFormat: "{{build_id}}",
                    },
                ],
                fieldConfig: { defaults: { unit: "bytes" } },
            },
            {
                title: "‚úèÔ∏è Cache Writes",
                type: "timeseries",
                gridPos: { h: 4, w: 6, x: 12, y: 8 },
                targets: [
                    {
                        expr: `rate(kn_next_bytecode_cache_write_count{app="${appName}"}[$__rate_interval])`,
                        legendFormat: "writes/s",
                    },
                ],
                fieldConfig: { defaults: { unit: "ops" } },
            },
            {
                title: "üß† Memory (RSS)",
                type: "timeseries",
                gridPos: { h: 6, w: 12, x: 0, y: 12 },
                targets: [
                    {
                        expr: `process_resident_memory_bytes{app="${appName}"}`,
                        legendFormat: "RSS - {{pod}}",
                    },
                ],
                fieldConfig: { defaults: { unit: "bytes" } },
            },
            {
                title: "‚ö° Event Loop Lag",
                type: "timeseries",
                gridPos: { h: 6, w: 12, x: 12, y: 12 },
                targets: [
                    {
                        expr: `nodejs_eventloop_lag_seconds{app="${appName}"}`,
                        legendFormat: "{{pod}}",
                    },
                ],
                fieldConfig: { defaults: { unit: "s" } },
            },
            {
                title: "üíª CPU Usage",
                type: "timeseries",
                gridPos: { h: 6, w: 8, x: 0, y: 18 },
                targets: [
                    {
                        expr: `rate(process_cpu_user_seconds_total{app="${appName}"}[$__rate_interval])`,
                        legendFormat: "User - {{pod}}",
                    },
                    {
                        expr: `rate(process_cpu_system_seconds_total{app="${appName}"}[$__rate_interval])`,
                        legendFormat: "System - {{pod}}",
                    },
                ],
                fieldConfig: { defaults: { unit: "percentunit" } },
            },
            {
                title: "üö¶ Active Requests",
                type: "timeseries",
                gridPos: { h: 6, w: 8, x: 8, y: 18 },
                targets: [
                    {
                        expr: `nodejs_active_requests{app="${appName}"}`,
                        legendFormat: "Requests - {{pod}}",
                    },
                ],
            },
            {
                title: "üéõÔ∏è Active Handles",
                type: "timeseries",
                gridPos: { h: 6, w: 8, x: 16, y: 18 },
                targets: [
                    {
                        expr: `nodejs_active_handles{app="${appName}"}`,
                        legendFormat: "Handles - {{pod}}",
                    },
                ],
            },
        ],
        refresh: "10s",
        schemaVersion: 39,
        tags: ["kn-next", "bytecode", appName],
        title: `kn-next: ${appName} Bytecode Cache`,
        uid: `kn-next-${appName}`,
        version: 1,
    };

    return JSON.stringify(dashboard, null, 2);
}
